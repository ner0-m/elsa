#pragma once

#include <memory>
#include <optional>

#include "IterativeSolver.h"
#include "LinearOperator.h"
#include <Eigen/Core>

namespace elsa
{
    /**
     * @brief Class implementing the AB_GMRES method for solving with an unmatched Back Projector
     *
     * @author Daniel Klitzner - initial code
     *
     * GMRES is an iterative method for solving an indefinite nonsymmetric linear system \f$ Ax = b
     * It solves the system by minimizing a least
     * squares Problem for \f$ J(y) = \left\| \beta {e_{1}} - \bar{H}y \right\| \f$ where \f$ \beta
     * \f$ is \f$ \left\| f - Ax \right\| \f$, \f$ {e_{1}} \f$ is the first column of the \f$ (k +
     * 1) \times (k + 1) \f$ identity matrix and \f$ \bar{H} \f$ is \f$ (k + 1) \times (k) \f$
     * matrix whose only nonzero entries are generated by the algorithm.
     *
     * We implement an expanded AB_GMRES method for solving large sparse least square problems. Here
     * we define \f$ A^T = B \f$ for our matrix \f$ A \epsilon \mathbb{R}^{m \times n} \f$ with
     * \f$ B \epsilon \mathbb{R}^{n \times m} \f$. We solve the so-called unmatched normal equations
     * \f$ BAx = Bb \f$ and \f$ ABy = b \f$  where \f$ x = By \f$:
     *
     * AB_GMRES solves \f$ min_{y \epsilon \mathbb{R}^m} \left\| b - ABy \right\|\f$, \f$ x = By
     * \f$.
     *
     * \f$ A \f$ can be imagined as a discretization of the forward projector, while \f$ B \f$
     * represents an matched or unmatched back projector or preconditioner/backprojector, the
     * algorithm can reach semi-convergence when \f$ A^T \neq B \f$ as long as valid models for
     * the projector / backprojector pair are chosen
     *
     * Convergence is considered reached when \f$ ||r|| <= epsilon \f$
     *
     * References:
     * http://epubs.siam.org/doi/10.1137/0907058
     * http://epubs.siam.org/doi/10.1137/070696313
     * http://arxiv.org/abs/2110.01481
     */
    template <typename data_t = real_t>
    class IS_AB_GMRES : public IterativeSolver<data_t>
    {
    public:
        using IS = IterativeSolver<data_t>;
        using Scalar = typename IS::Scalar;
        using Callback = typename IS::Callback;

        /** @brief Constructor for AB_GMRES, accepting a forward projector A,
         *a sinogram b and an optional value for epsilon, the backprojector B will be the adjoint
         *of projector A
         * @param[in] projector Discretization of a forward projector
         * @param[in] sinogram sinogram of measured Data when applying phantom to projector
         * @param[in] epsilon affects the stopping condition
         **/
        explicit IS_AB_GMRES(const LinearOperator<data_t>& projector,
                             const DataContainer<data_t>& sinogram,
                             data_t epsilon = std::numeric_limits<data_t>::epsilon());

        /** @brief Constructor for AB_GMRES, accepting a forward projector A, an
         *unmatched backprojector B, a sinogram b and an optional value for
         *epsilon
         * @param[in] projector Discretization of a forward projector A
         * @param[in] backprojector An optional unmatched/matched backprojector B
         * @param[in] sinogram sinogram "b" of measured Data when applying phantom to projector
         * @param[in] epsilon affects the stopping condition
         **/
        IS_AB_GMRES(const LinearOperator<data_t>& projector,
                    const LinearOperator<data_t>& backprojector,
                    const DataContainer<data_t>& sinogram,
                    data_t epsilon = std::numeric_limits<data_t>::epsilon());

        /// make copy constructor deletion explicit
        IS_AB_GMRES(const IS_AB_GMRES<data_t>&) = delete;

        /// default destructor
        ~IS_AB_GMRES() override = default;

        /** @brief Solves the given Linear System using AB-GMRES as default, i.e. apply
         * i iterations with r restarts of AB-GMRES
         * @param[in] iterations number of iterations to execute
         * @param[in] restarts number of restarts to execute after iterations
         * @param[in] x0 optional approximate starting positions (used for preconditioning)
         * @return an approximated solution
         **/
        DataContainer<data_t>
            solveAndRestart(index_t iterations, index_t restarts,
                            std::optional<DataContainer<data_t>> x0 = std::nullopt);

        /** @brief Solves the given Linear System using AB-GMRES as default, i.e. apply
         * i iterations of AB-GMRES
         * @param[in] iterations number of iterations to execute
         * @param[in] x0 optional approximate starting positions (used for preconditioning)
         * @return an approximated solution
         **/
        DataContainer<data_t> solve(index_t iterations,
                                    std::optional<DataContainer<data_t>> x0 = std::nullopt);

        void reset() override;
        DataContainer<data_t> step(DataContainer<data_t>) override;

    protected:
        /// implement the polymorphic clone operation
        IS_AB_GMRES<data_t>* cloneImpl() const override;

        /// implement the polymorphic comparison operation
        bool isEqual(const IterativeSolver<data_t>& other) const override;

    private:
        /// Unmatched Backprojector B, used for Preconditioning
        std::unique_ptr<LinearOperator<data_t>> _B;

        /// variable affecting the stopping condition
        data_t _epsilon;
    };
} // namespace elsa
